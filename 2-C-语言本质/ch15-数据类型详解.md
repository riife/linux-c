# 第 15 章 数据类型详解

## 1. 整型

我们知道，在 C 语言中 char 型占一个字节的存储空间，一个字节通常是 8 个 bit。如果这 8 个 bit 按无符号整数来解释，取值范围是 0 ~ 255，如果按有符号整数来解释，采用 2's Complement 表示法，取值范围是 -128 ~ 127。C 语言规定了 signed 和 unsigned 两个关键字，unsigned char 型表示无符号数，signed char 型表示有符号数。

那么以前我们常用的不带 signed 或 unsigned 关键字的 char 型是无符号数还是有符号数呢？C 标准规定这是 Implementation Defined，编译器可以定义 char 型是无符号的，也可以定义 char 型是有符号的，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种实现，x86 平台的 `gcc` 定义 char 型是有符号的。这也是 C 标准的 Rationale 之一：**优先考虑效率，而可移植性尚在其次**。这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用。另一方面，写不可移植的代码有时候也是必要的，比如 Linux 内核代码使用了很多只有 `gcc` 支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写，如果不是为了效率，一般来说就没有理由故意写不可移植的代码。从现在开始，我们会接触到很多 Implementation Defined 的特性，C 语言与平台和编译器是密不可分的，离开了具体的平台和编译器讨论 C 语言，就只能讨论到本书第一部分的程度了。注意，ASCII 码的取值范围是 0 ~ 127，所以不管 char 型是有符号的还是无符号的，存一个 ASCII 码都没有问题，一般来说，如果用 `char` 型存 ASCII 码字符，就不必明确写是 signed 还是 unsigned，如果用 char 型表示 8 位的整数，为了可移植性就必须写明是 signed 还是 unsigned。

> **Implementation-defined、Unspecified 和 Undefined**
>
> 在 C 标准中没有做明确规定的地方会用 Implementation-defined、Unspecified 或 Undefined 来表述，在本书中有时把这三种情况统称为「未明确定义」的。这三种情况到底有什么不同呢？
> 我们刚才看到一种 Implementation-defined 的情况，C 标准没有明确规定 char 是有符号的还是无符号的，但是要求编译器必须对此做出明确规定，并写在编译器的文档中。
> 而对于 Unspecified 的情况，往往有几种可选的处理方式，C 标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即便用同一个编译器的不同版本来编译也可能得到不同的结果，因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式，比如下一章我们会讲到一个函数调用的各个实参表达式按什么顺序求值是 Unspecified 的。
> Undefined 的情况则是完全不确定的，C 标准没规定怎么处理，编译器很可能也没规定，甚至也没做出错处理，有很多 Undefined 的情况编译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就是 Undefined 的。
> 初学者看到这些规则通常会很不舒服，觉得这不是在学编程而是在啃法律条文，结果越学越泄气。是的，C 语言并不像一个数学定理那么完美，现实世界里的东西总是不够完美的。但还好啦，C 程序员已经很幸福了，只要严格遵照 C 标准来写代码，不要去触碰那些阴暗角落，写出来的代码就有很好的可移植性。想想那些可怜的 JavaScript 程序员吧，他们甚至连一个可以遵照的标准都没有，一个浏览器一个样，甚至同一个浏览器的不同版本也差别很大，程序员不得不为每一种浏览器的每一个版本分别写不同的代码。

除了 char 型之外，整型还包括 short int（或者简写为 short）、int、long int（或者简写为 long）、long long int（或者简写为 long long）等几种<sup>[25]</sup>，这些类型都可以加上 signed 或 unsigned 关键字表示有符号或无符号数。其实，对于有符号数在计算机中的表示是 Sign and Magnitude、1's Complement 还是 2's Complement，C 标准也没有明确规定，也是 Implementation Defined。大多数体系结构都采用 2's Complement 表示法，x86 平台也是如此，从现在开始我们只讨论 2's Complement 表示法的情况。还有一点要注意，除了 char 型以外的这些类型如果不明确写 signed 或 unsigned 关键字都表示 signed，这一点是 C 标准明确规定的，不是 Implementation Defined。

> <sup>[25]</sup> 我们在[第 19 章「汇编与 C 之间的关系」第 4 节「结构体和联合体」](2-C-语言本质/ch19-汇编与-C-之间的关系#_4-结构体和联合体)还要介绍一种特殊的整型—— Bit-field。

除了 char 型在 C 标准中明确规定占一个字节之外，其它整型占几个字节都是 Implementation Defined。通常的编译器实现遵守 ILP32 或 LP64 规范，如下表所示。

<p id="t15-1">表 15.1. ILP32 和 LP64</p>

| 类型      | ILP32（位数） | LP64（位数） |
| --------- | ------------- | ------------ |
| char      | 8             | 8            |
| short     | 16            | 16           |
| int       | 32            | 32           |
| long      | 32            | 64           |
| long long | 64            | 64           |
| 指针      | 32            | 64           |

ILP32 这个缩写的意思是 int（I）、long（L）和指针（P）类型都占 32 位，通常 32 位计算机的 C 编译器采用这种规范，x86 平台的 `gcc` 也是如此。LP64 是指 long（L）和指针占 64 位，通常 64 位计算机的 C 编译器采用这种规范。指针类型的长度总是和计算机的位数一致，至于什么是计算机的位数，指针又是一种什么样的类型，我们到[第 17 章「计算机体系结构基础」](2-C-语言本质/ch17-计算机体系结构基础)和[第 23 章「指针」](2-C-语言本质/ch23-指针)再分别详细解释。从现在开始本书做以下约定：**在以后的陈述中，缺省平台是 x86 / Linux / gcc，遵循 ILP32，并且 char 是有符号的，我不会每次都加以说明，但说到其它平台时我会明确指出是什么平台**。

在[第 2 章「常量、变量和表达式」第 2 节「常量」](1-C-语言入门/ch02-常量、变量和表达式#_2-常量)讲过 C 语言的常量有整数常量、字符常量、枚举常量和浮点数常量四种，其实字符常量和枚举常量的类型都是 int 型，因此前三种常量的类型都属于整型。整数常量有很多种，不全是 int 型的，下面我们详细讨论整数常量。

以前我们只用到十进制的整数常量，其实在 C 语言中也可以用八进制和十六进制的整数常量<sup>[26]</sup>。八进制整数常量以 `0` 开头，后面的数字只能是 0 ~ 7，例如 022，因此十进制的整数常量就不能以 0 开头了，否则无法和八进制区分。十六进制整数常量以 `0x` 或 `0X` 开头，后面的数字可以是 `0 ~ 9`、`a ~ f` 和 `A ~ F`。在[第 2 章「常量、变量和表达式」第 6 节「字符类型与字符编码」](1-C-语言入门/ch02-常量、变量和表达式#_6-字符类型与字符编码)讲过一种转义序列，以 `\` 或 `\x` 加八进制或十六进制数字表示，这种表示方式相当于把八进制和十六进制整数常量开头的 `0` 替换成 `\` 了。

> <sup>[26]</sup> 有些编译器（比如 `gcc`）也支持二进制的整数常量，以 `0b` 或 `0B` 开头，比如 `0b0001111`，但二进制的整数常量从未进入 C 标准，只是某些编译器的扩展，所以不建议使用，由于二进制和八进制、十六进制的对应关系非常明显，用八进制或十六进制常量完全可以代替使用二进制常量。

整数常量还可以在末尾加 `u` 或 `U` 表示 unsigned，加 `l` 或 `L` 表示 long，加 `ll` 或 `LL` 表示 long long，例如 `0x1234U`，`98765ULL` 等。但事实上 `u`、`l`、`ll` 这几种后缀和上面讲的 unsigned、long、long long 关键字并不是一一对应的。这个对应关系比较复杂，准确的描述如下表所示（出自 _C99_ 条款 6.4.4.1）。

<p id="t15-2">表 15.2. 整数常量的类型</p>

| 后缀                       | 十进制常量                                            | 八进制或十六进制常量                                                             |
| -------------------------- | ----------------------------------------------------- | -------------------------------------------------------------------------------- |
| 无                         | int long int long long int                            | int unsigned int long int unsigned long int long long int unsigned long long int |
| u 或 U                     | unsigned int unsigned long int unsigned long long int | unsigned int unsigned long int unsigned long long int                            |
| l 或 L                     | long int long long int                                | long int unsigned long int long long int unsigned long long int                  |
| 既有 u 或 U，又有 l 或 L   | unsigned long int unsigned long long int              | unsigned long int unsigned long long int                                         |
| ll 或 LL                   | long long int                                         | long long int unsigned long long int                                             |
| 既有 u 或 U，又有 ll 或 LL | unsigned long long int                                | unsigned long long int                                                           |

给定一个整数常量，比如 `1234U`，那么它应该属于「u 或 U」这一行的「十进制常量」这一列，这个表格单元中列了三种类型 unsigned int、unsigned long int、unsigned long long int，从上到下找出第一个足够长的类型可以表示 `1234` 这个数，那么它就是这个整数常量的类型，如果 int 是 32 位的那么 unsigned int 就可以表示。

再比如 `0xffff0000`，应该属于第一行「无」的第二列「八进制或十六进制常量」，这一列有六种类型 int、unsigned int、long int、unsigned long int、long long int、unsigned long long int，第一个类型 int 表示不了 `0xffff0000` 这么大的数，我们写这个十六进制常量是要表示一个正数，而它的 MSB（第 31 位）是 1，如果按有符号 int 类型来解释就成了负数了，第二个类型 unsigned int 可以表示这个数，所以这个十六进制常量的类型应该算 unsigned int。所以请注意，`0x7fffffff` 和 `0xffff0000` 这两个常量虽然看起来差不多，但前者是 int 型，而后者是 unsigned int 型。

讲一个有意思的问题。我们知道 x86 平台上 int 的取值范围是 -2147483648 ~ 2147483647，那么用 `printf("%d\n", -2147483648);` 打印 int 类型的下界有没有问题呢？如果用 `gcc main.c -std=c99` 编译会有警告信息： `warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘long long int’`。这是因为，虽然 -2147483648 这个数值能够用 int 型表示，但在 C 语言中却没法写出对应这个数值的 int 型常量，C 编译器会把它当成一个整数常量 2147483648 和一个负号运算符组成的表达式，而整数常量 2147483648 已经超过了 `int` 型的取值范围，在 x86 平台上 int 和 long 的取值范围相同，所以这个常量也超过了 long 型的取值范围，根据上表第一行「无」的第一列「十进制常量」，这个整数常量应该算 long long 型的，前面再加个负号组成的表达式仍然是 long long 型，而 `printf` 的 `%d` 转换说明要求后面的参数是 int 型，所以编译器报警告。之所以编译命令要加 `-std=c99` 选项是因为 C99 以前对于整数常量的类型规定和上表有一些出入，即使不加这个选项也会报警告，但警告信息不准确，读者可以试试。如果改成 `printf("%d\n", -2147483647-1);` 编译器就不会报警告了，`-` 号运算符的两个操作数 -2147483647 和 1 都是 int 型，计算结果也应该是 int 型，并且它的值也没有超出 int 型的取值范围；或者改成 `printf("%lld\n", -2147483648);` 也可以，转换说明 `%lld` 告诉 `printf` 后面的参数是 long long 型，有些转换说明格式目前还没讲到，详见[第 25 章「C 标准库」第 2.9 节「格式化 I/O 函数」](2-C-语言本质/ch25-C-标准库#_格式化-IO-函数)。

怎么样，整数常量没有你原来想的那么简单吧。再看一个不简单的问题。`long long i = 1234567890 * 1234567890;` 编译时会有警告信息： `warning: integer overflow in expression`。1234567890 是 int 型，两个 int 型相乘的表达式仍然是 int 型，而乘积已经超过 int 型的取值范围了，因此提示计算结果溢出。如果改成 `long long i = 1234567890LL * 1234567890;`，其中一个常量是 long long 型，另一个常量也会先转换成 long long 型再做乘法运算，两数相乘的表达式也是 long long 型，编译器就不会报警告了。有关类型转换的规则将在[本章第 3 节「类型转换」](#_类型转换)详细介绍。

## 2. 浮点型

C 标准规定的浮点型有 float、double、long double，和整型一样，既没有规定每种类型占多少字节，也没有规定采用哪种表示形式。浮点数的实现在各种平台上差异很大，有的处理器有浮点运算单元（FPU，Floating Point Unit），称为硬浮点（Hard-float）实现；有的处理器没有浮点运算单元，只能做整数运算，需要用整数运算来模拟浮点运算，称为软浮点（Soft-float）实现。大部分平台的浮点数实现遵循 IEEE 754，float 型通常是 32 位，double 型通常是 64 位。

long double 型通常是比 double 型精度更高的类型，但各平台的实现有较大差异。在 x86 平台上，大多数编译器实现的 long double 型是 80 位，因为 x86 的浮点运算单元具有 80 位精度，`gcc` 实现的 long double 型是 12 字节（96 位），这是为了对齐到 4 字节边界（在[第 19 章「汇编与 C 之间的关系」第 4 节「结构体和联合体」](2-C-语言本质/ch19-汇编与-C-之间的关系#_4-结构体和联合体)详细讨论对齐的问题），也有些编译器实现的 long double 型和 double 型精度相同，没有充分利用 x86 浮点运算单元的精度。其它体系结构的浮点运算单元的精度不同，编译器实现也会不同，例如 PowerPC 上的 long double 型通常是 128 位。

以前我们只用到最简单的浮点数常量，例如 3.14，现在看看浮点数常量还有哪些写法。由于浮点数在计算机中的表示是基于科学计数法的，所以浮点数常量也可以写成科学计数法的形式，尾数和指数之间用 e 或 E 隔开，例如 314e-2 表示 314×10<sup>-2</sup>，注意这种表示形式基数是 10 <sup>[27]</sup>，如果尾数的小数点左边或右边没有数字则表示这一部分为零，例如 3.e-1，.987 等等。浮点数也可以加一个后缀，例如 3.14f、.01L，浮点数的后缀和类型之间的对应关系比较简单，没有后缀的浮点数常量是 double 型的，有后缀 f 或 F 的浮点数常量是 float 型的，有后缀 l 或 L 的浮点数常量是 long double 型的。

> <sup>[27]</sup> C99 引入一种新的十六进制浮点数表示，基数是 2，本书不做详细介绍。

## 3. 类型转换

如果有人问 C 语法规则中最复杂的是哪一部分，我一定会说是类型转换。从上面两节可以看出，有符号、无符号整数和浮点数加起来有那么多种类型，每两种类型之间都要定义一个转换规则，转换规则的数量自然很庞大，更何况由于各种体系结构对于整数和浮点数的实现很不相同，很多类型转换的情况都是 C 标准未做明确规定的阴暗角落。虽然我们写代码时不会故意去触碰这些阴暗角落，但有时候会不小心犯错，所以了解一些未明确规定的情况还是有必要的，可以在出错时更容易分析错误原因。本节分成几小节，首先介绍哪些情况下会发生类型转换，会把什么类型转成什么类型，然后介绍编译器如何处理这样的类型转换。

### 3.1. Integer Promotion

在一个表达式中，凡是可以使用 int 或 unsigned int 类型做右值的地方也都可以使用有符号或无符号的 char 型、short 型和 Bit-field。如果原始类型的取值范围都能用 int 型表示，则其类型被提升为 int，如果原始类型的取值范围用 int 型表示不了，则提升为 unsigned int 型，这称为 Integer Promotion。做 Integer Promotion 只影响上述几种类型的值，对其它类型无影响。C99 规定 Integer Promotion 适用于以下几种情况：

1. 如果一个函数的形参类型未知，例如使用了 Old Style C 风格的函数声明（详见[第 3 章「简单函数」第 2 节「自定义函数」](1-C-语言入门/ch03-简单函数#_2-自定义函数)），或者函数的参数列表中有 ...，那么调用函数时要对相应的实参做 Integer Promotion，此外，相应的实参如果是 float 型的也要被提升为 double 型，这条规则称为 Default Argument Promotion。我们知道 `printf` 的参数列表中有 `...`，除了第一个形参之外，其它形参的类型都是未知的，比如有这样的代码：

   ```c
   char ch = 'A';
   printf("%c", ch);
   ```

   `ch` 要被提升为 int 型之后再传给 `printf`。

2. 算术运算中的类型转换。有符号或无符号的 char 型、short 型和 Bit-field 在做算术运算之前首先要做 Integer Promotion，然后才能参与计算。例如：

   ```c
   unsigned char c1 = 255, c2 = 2;
   int n = c1 + c2;
   ```

   计算表达式 `c1 + c2` 的过程其实是先把 `c1` 和 `c2` 提升为 int 型然后再相加（unsigned char 的取值范围是 0 ~ 255，完全可以用 int 表示，所以提升为 int 就可以了，不需要提升为 unsigned int），整个表达式的值也是 int 型，最后的结果是 257。假如没有这个提升的过程，`c1 + c2` 就溢出了，溢出会得到什么结果是 Undefined，在大多数平台上会把进位截掉，得到的结果应该是 1。

   除了 + 号之外还有哪些运算符在计算之前需要做 Integer Promotion 呢？我们在下一小节先介绍 Usual Arithmetic Conversion 规则，然后再解答这个问题。

### 3.2. Usual Arithmetic Conversion

两个算术类型的操作数做算术运算，比如 `a + b`，如果两边操作数的类型不同，编译器会自动做类型转换，使两边类型相同之后才做运算，这称为 Usual Arithmetic Conversion。转换规则如下：

1. 如果有一边的类型是 long double，则把另一边也转成 long double。
2. 否则，如果有一边的类型是 double，则把另一边也转成 double。
3. 否则，如果有一边的类型是 float，则把另一边也转成 float。
4. 否则，两边应该都是整型，首先按上一小节讲过的规则对 `a` 和 `b` 做 Integer Promotion，然后如果类型仍不相同，则需要继续转换。首先我们规定 char、short、int、long、long long 的转换级别（Integer Conversion Rank）一个比一个高，同一类型的有符号和无符号数具有相同的 Rank。转换规则如下：
   1. 如果两边都是有符号数，或者都是无符号数，那么较低 Rank 的类型转换成较高 Rank 的类型。例如 unsigned int 和 unsigned long 做算术运算时都转成 unsigned long。
   2. 否则，如果一边是无符号数另一边是有符号数，无符号数的 Rank 不低于有符号数的 Rank，则把有符号数转成另一边的无符号类型。例如 unsigned long 和 int 做算术运算时都转成 unsigned long，unsigned long 和 long 做算术运算时也都转成 unsigned long。
   3. 剩下的情况是：一边有符号另一边无符号，并且无符号数的 Rank 低于有符号数的 Rank。这时又分为两种情况，如果这个有符号数类型能够覆盖这个无符号数类型的取值范围，则把无符号数转成另一边的有符号类型。例如遵循 LP64 的平台上 unsigned int 和 long 在做算术运算时都转成 long。
   4. 否则，也就是这个有符号数类型不足以覆盖这个无符号数类型的取值范围，则把两边都转成有符号数的 Rank 对应的无符号类型。例如在遵循 ILP32 的平台上 unsigned int 和 long 在做算术运算时都转成 unsigned long。

可见有符号和无符号整数的转换规则是十分复杂的，虽然这是有明确规定的，不属于阴暗角落，但为了程序的可读性不应该依赖这些规则来写代码。我讲这些规则，不是为了让你用，而是为了让你了解有符号数和无符号数混用会非常麻烦，从而避免触及这些规则，并且在程序出错时记得往这上面找原因。所以这些规则不需要牢记，但要知道有这么回事，以便在用到的时候能找到我书上的这一段。

到目前为止我们学过的 `+  - * / % > < >= <= == !=` 运算符都需要做 Usual Arithmetic Conversion，因为都要求两边操作数的类型一致，在下一章会介绍几种新的运算符也需要做 Usual Arithmetic Conversion。单目运算符 `+ - ~` 只有一个操作数，移位运算符 `<<  >>` 两边的操作数类型不要求一致，这些运算不需要做 Usual Arithmetic Conversion，但也需要做 Integer Promotion，运算符 `~ << >>` 将在下一章介绍。

### 3.3. 由赋值产生的类型转换

如果赋值或初始化时等号两边的类型不相同，则编译器会把等号右边的类型转换成等号左边的类型再做赋值。例如 `int c = 3.14;`，编译器会把右边的 double 型转成 int 型再赋给变量 `c`。

我们知道，函数调用传参的过程相当于定义形参并且用实参对其做初始化，函数返回的过程相当于定义一个临时变量并且用 `return` 的表达式对其做初始化，所以由赋值产生的类型转换也适用于这两种情况。例如一个函数的原型是 `int foo(int, int);`，则调用 `foo(3.1, 4.2)` 时会自动把两个 double 型的实参转成 int 型赋给形参，如果这个函数定义中有返回语句 `return 1.2;`，则返回值 `1.2` 会自动转成 int 型再返回。

在函数调用和返回过程中发生的类型转换往往容易被忽视，因为函数原型和函数调用并没有写在一起。例如 `char c = getchar();`，看到这一句往往会想当然地认为 `getchar` 的返回值是 char 型，而事实上 `getchar` 的返回值是 int 型，这样赋值会引起类型转换，可能产生 Bug，我们在[第 25 章「C 标准库」第 2.5 节「以字节为单位的 I/O 函数」](2-C-语言本质/ch25-C-标准库#_25-以字节为单位的-IO-函数)详细讨论这个问题。

### 3.4. 强制类型转换

以上三种情况通称为隐式类型转换（Implicit Conversion，或者叫 Coercion），编译器根据它自己的一套规则将一种类型自动转换成另一种类型。除此之外，程序员也可以通过类型转换运算符（Cast Operator）自己规定某个表达式要转换成何种类型，这称为显式类型转换（Explicit Conversion）或强制类型转换（Type Cast）。例如计算表达式 `(double)3 + i`，首先将整数 3 强制转换成 double 型（值为 3.0），然后和整型变量 `i` 相加，这时适用 Usual Arithmetic Conversion 规则，首先把 `i` 也转成 double 型，然后两者相加，最后整个表达式也是 double 型的。这里的 `(double)` 就是一个类型转换运算符，这种运算符由一个类型名套 `()` 括号组成，属于单目运算符，后面的 3 是这个运算符的操作数。注意操作数的类型必须是标量类型，转换之后的类型必须是标量类型或者 `void` 型。

### 3.5. 编译器如何处理类型转换

以上几小节介绍了哪些情况下会发生类型转换，并且明确了每种情况下会把什么类型转成什么类型，本节介绍编译器如何处理任意两种类型之间的转换。现在要把一个 M 位的类型（值为 X）转换成一个 N 位的类型，所有可能的情况如下表所示。

<p id="t15-3">表 15.3. 如何做类型转换</p>

| 待转换的类型                                 | M > N 的情况                                                                                       | M == N 的情况                                                      | M < N 的情况      |
| -------------------------------------------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | ----------------- |
| signed integer to signed integer             | 如果 X 在目标类型的取值范围内则值不变，否则 Implementation-defined                                 | 值不变                                                             | 值不变            |
| unsigned integer to signed integer           | 如果 X 在目标类型的取值范围内则值不变，否则 Implementation-defined                                 | 如果 X 在目标类型的取值范围内则值不变，否则 Implementation-defined | 值不变            |
| signed integer to unsigned integer           | X % 2<sup>N</sup>                                                                                  | X % 2<sup>N</sup>                                                  | X % 2<sup>N</sup> |
| unsigned integer to unsigned integer         | X % 2<sup>N</sup>                                                                                  | 值不变                                                             | 值不变            |
| floating-point to signed or unsigned integer | Truncate toward Zero，如果 X 的整数部分超出目标类型的取值范围则 Undefined                          |                                                                    |                   |
| signed or unsigned integer to floating-point | 如果 X 在目标类型的取值范围内则值不变，但有可能损失精度，如果 X 超出目标类型的取值范围则 Undefined |                                                                    |                   |
| floating-point to floating-point             | 如果 X 在目标类型的取值范围内则值不变，但有可能损失精度，如果 X 超出目标类型的取值范围则 Undefined | 值不变                                                             | 值不变            |

注意上表中的 **X % 2<sup>N</sup>**，我想表达的意思是「把 X 加上或者减去 2<sup>N</sup> 的整数倍，使结果落入 [0, 2<sup>N-1</sup>] 的范围内」，当 X 是负数时运算结果也得是正数，即运算结果和除数同号而不是和被除数同号，这不同于 C 语言 % 运算的定义。写程序时不要故意用上表中的规则，尤其不要触碰 Implementation-defined 和 Undefined 的情况，但程序出错时可以借助上表分析错误原因。

下面举几个例子说明上表的用法。比如把 double 型转换成 short 型，对应表中的「floating-point to signed or unsigned integer」，如果原值在 (-32769.0, 32768.0) 之间则截掉小数部分得到转换结果，否则产生溢出，结果是 Undefined，例如对于 `short s = 32768.4;` 这个语句 `gcc` 会报警告。

比如把 int 型转换成 `unsigned short` 型，对应表中的「signed integer to unsigned integer」，如果原值是正的，则把它除以 216 取模，其实就是取它的低 16 位，如果原值是负的，则加上 216 的整数倍，使结果落在 [0, 65535] 之间。

比如把 int 类型转换成 short 类型，对应表中的「signed integer to signed integer」，如果原值在 [-32768, 32767] 之间则值不变，否则产生溢出，结果是 Implementation-defined，例如对于 `short s = -32769;` 这个语句 `gcc` 会报警告。

最后一个例子，把 short 型转换成 int 型，对应表中的「signed integer to signed integer」，转换之后应该值不变。那怎么维持值不变呢？是不是在高位补 16 个 0 就行了呢？如果原值是 -1，十六进制表示就是 ffff，要转成 int 型的 -1 需要变成 ffffffff，因此需要在高位补 16 个 1 而不是 16 个 0。换句话说，要维持值不变，在高位补 1 还是补 0 取决于原来的符号位，这称为符号扩展（Sign Extension）。

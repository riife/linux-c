# 第 32 章 正则表达式

## 1. 引言

以前我们用 `grep` 在一个文件中找出包含某些字符串的行，比如在头文件中找出一个宏定义。其实 `grep` 还可以找出**符合某个模式（Pattern）的一类字符串**。例如找出所有符合 `xxxxx@xxxx.xxx` 模式的字符串（也就是 email 地址），要求 `x` 字符可以是字母、数字、下划线、小数点或减号，email 地址的每一部分可以有一个或多个 `x` 字符，例如 `abc.d@ef.com`、`1_2@987-6.54`，当然符合这个模式的不全是合法的 email 地址，但至少可以做一次初步筛选，筛掉 `a.b`、`c@d` 等肯定不是 email 地址的字符串。再比如，找出所有符合 `yyy.yyy.yyy.yyy` 模式的字符串（也就是 IP 地址），要求 y 是 0 - 9 的数字，IP 地址的每一部分可以有 1 - 3 个 y 字符。

如果要用 `grep` 查找一个模式，如何表示这个模式，这一类字符串，而不是一个特定的字符串呢？从这两个简单的例子可以看出，要表示一个模式至少应该包含以下信息：

- 字符类（Character Class）：如上例的 x 和 y，它们在模式中表示一个字符，但是取值范围是一类字符中的任意一个。
- 数量限定符（Quantifier）： 邮件地址的每一部分可以有**一个或多个** x 字符，IP 地址的每一部分可以有 **1 - 3 个** y 字符
- 各种字符类以及普通字符之间的位置关系：例如邮件地址分三部分，用普通字符 `@` 和 `.` 隔开，IP 地址分四部分，用 `.` 隔开，每一部分都可以用字符类和数量限定符描述。为了表示位置关系，还有位置限定符（Anchor）的概念，将在下面介绍。

规定一些特殊语法表示字符类、数量限定符和位置关系，然后用这些特殊语法和普通字符一起表示一个模式，这就是正则表达式（Regular Expression）。例如 email 地址的正则表达式可以写成 `[a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+\.[a-zA-Z0-9_.-]+`，IP 地址的正则表达式可以写成 `[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}`。下一节介绍正则表达式的语法，我们先看看正则表达式在 `grep` 中怎么用。例如有这样一个文本文件 `testfile`：

```txt
192.168.1.1
1234.234.04.5678
123.4234.045.678
abcde
```

查找其中包含 IP 地址的行：

```bash
$ egrep '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' testfile
192.168.1.1
1234.234.04.5678
```

`egrep` 相当于 `grep -E`，表示采用 Extended 正则表达式语法。`grep` 的正则表达式有 Basic 和 Extended 两种规范，它们之间的区别下一节再解释。另外还有 `fgrep` 命令，相当于 `grep -F`，表示只搜索固定字符串而不搜索正则表达式模式，不会按正则表达式的语法解释后面的参数。

注意正则表达式参数用单引号括起来了，因为正则表达式中用到的很多特殊字符在 Shell 中也有特殊含义（例如 `\`），只有用单引号括起来才能保证这些字符原封不动地传给 `grep` 命令，而不会被 Shell 解释掉。

`192.168.1.1` 符合上述模式，由三个 `.` 隔开的四段组成，每段都是 1 到 3 个数字，所以这一行被找出来了，可为什么 `1234.234.04.5678` 也被找出来了呢？因为 `grep` 找的是**包含**某一模式的行，这一行包含一个符合模式的字符串 `234.234.04.567`。相反，`123.4234.045.678` 这一行不包含符合模式的字符串，所以不会被找出来。

`grep` 是一种查找过滤工具，正则表达式在 `grep`中用来查找符合模式的字符串。其实正则表达式还有一个重要的应用是验证用户输入是否合法，例如用户通过网页表单提交自己的 email 地址，就需要用程序验证一下是不是合法的 email 地址，这个工作可以在网页的 JavaScript 中做，也可以在网站后台的程序中做，例如 PHP、Perl、Python、Ruby、Java 或 C，所有这些语言都支持正则表达式，可以说，目前不支持正则表达式的编程语言实在很少见。除了编程语言之外，很多 UNIX 命令和工具也都支持正则表达式，例如 grep、vi、sed、awk、emacs 等等。「正则表达式」就像「变量」一样，它是一个广泛的概念，而不是某一种工具或编程语言的特性。

## 1. 基本语法

我们知道 C 的变量和 Shell 脚本变量的定义和使用方法很不相同，表达能力也不相同，C 的变量有各种类型，而 Shell 脚本变量都是字符串。同样道理，各种工具和编程语言所使用的正则表达式规范的语法并不相同，表达能力也各不相同，有的正则表达式规范引入很多扩展，能表达更复杂的模式，但各种正则表达式规范的基本概念都是相通的。本节介绍 `egrep(1)` 所使用的正则表达式，它大致上符合 POSIX 正则表达式规范，详见 `regex(7)`（看这个 man page 对你的英文绝对是很好的锻炼）。希望读者仿照上一节的例子，一边学习语法，一边用 `egrep` 命令做实验。

<p id="t32-1">表 32.1. 字符类</p>

| 字符        | 含义                                                         | 举例                                                                                      |
| ----------- | ------------------------------------------------------------ | ----------------------------------------------------------------------------------------- |
| `.`         | 匹配任意一个字符                                             | `abc.` 可以匹配 `abcd`、`abc9` 等                                                         |
| `[]`        | 匹配括号中的任意一个字符                                     | `[abc]d` 可以匹配 `ad`、`bd` 或 `cd`                                                      |
| `-`         | 在 `[]` 括号内表示字符范围                                   | `[0-9a-fA-F]``` 可以匹配一位十六进制数字                                                  |
| `^`         | 位于 `[]` 括号内的开头，匹配除括号中的字符之外的任意一个字符 | `[^xy]` 匹配除 `xy` 之外的任一字符，因此 `[^xy]1` 可以匹配 `a1`、`b1` 但不匹配 `x1`、`y1` |
| `[[:xxx:]]` | `grep` 工具预定义的一些命名字符类                            | `[[:alpha:]]` 匹配一个字母，`[[:digit:]]` 匹配一个数字                                    |

<p id="t32-2">表 32.2. 数量限定符</p>

| 字符    | 含义                                             | 举例                                                                                                                 |
| ------- | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| `?`     | 紧跟在它前面的单元应匹配零次或一次               | `[0-9]?\.[0-9]` 匹配 `0.0`、`2.3`、`.5` 等，由于 `.` 在正则表达式中是一个特殊字符，所以需要用 `\` 转义一下，取字面值 |
| `+`     | 紧跟在它前面的单元应匹配一次或多次               | `[a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+\.[a-zA-Z0-9_.-]+` 匹配 email 地址                                                   |
| `*`     | 紧跟在它前面的单元应匹配零次或多次               | `[0-9][0-9]*` 匹配至少一位数字，等价于 `[0-9]+`，`[a-zA-Z_]+[a-zA-Z_0-9]*` 匹配 C 语言的标识符                       |
| `{N}`   | 紧跟在它前面的单元应精确匹配 `N` 次              | `[1-9][0-9]{2}` 匹配从 `100` 到 `999` 的整数                                                                         |
| `{N,}`  | 紧跟在它前面的单元应匹配至少 `N` 次              | `[1-9][0-9]{2,}`匹配三位以上（含三位）的整数                                                                         |
| `{,M}`  | 紧跟在它前面的单元应匹配最多 `M` 次              | `[0-9]{,1}` 相当于`[0-9]?`                                                                                           |
| `{N,M}` | 紧跟在它前面的单元应匹配至少 `N` 次，最多 `M` 次 | `[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}` 匹配 IP 地址                                                        |

再次注意 `grep` 找的是包含某一模式的行，而不是完全匹配某一模式的行。再举个例子，如果文本文件的内容是

```txt
aaabc
aad
efg
```

查找 `a*` 这个模式的结果是三行都被找出来了

```bash
$ egrep 'a*' testfile
aabc
aad
efg
```

`a*` 匹配 0 个或多个 `a`，而第三行包含 0 个`a`，所以也包含了这一模式。单独用 `a*` 这样的正则表达式做查找没什么意义，一般是把 `a*` 作为正则表达式的一部分来用。

<p id="t32-3">表 32.3. 位置限定符</p>

| 字符 | 含义                       | 举例                                                          |
| ---- | -------------------------- | ------------------------------------------------------------- |
| `^`  | 匹配行首的位置             | `^Content` 匹配位于一行开头的 `Content`                       |
| `$`  | 匹配行末的位置             | `;$` 匹配位于一行结尾的 `;` 号，`^$` 匹配空行                 |
| `\<` | 匹配单词开头的位置         | `\<th` 匹配 `... this`，但不匹配 `ethernet`、`tenth`          |
| `\>` | 匹配单词结尾的位置         | `p\>` 匹配 `leap ...`，但不匹配 `parent`、`sleepy`            |
| `\b` | 匹配单词开头或结尾的位置   | `\bat\b` 匹配 `... at ...`，但不匹配 `cat`、`atexit`、`batch` |
| `\B` | 匹配非单词开头和结尾的位置 | `\Bat\B` 匹配 `battery`，但不匹配 `... attend`、`hat ...`     |

位置限定符可以帮助 `grep` 更准确地查找，例如上一节我们用 `[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}` 查找 IP 地址，找到这两行

```bash
192.168.1.1
1234.234.04.5678
```

如果用 `^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$` 查找，就可以把 `1234.234.04.5678` 这一行过滤掉了。

<p id="t32-4">表 32.4. 其它特殊字符</p>

| 字符 | 含义                                                                 | 举例                                                                                          |
| ---- | -------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- | ---- | --------------------------- |
| `\`  | 转义字符，普通字符转义为特殊字符，特殊字符转义为普通字符             | 普通字符`<`写成`\<`表示单词开头的位置，特殊字符`.`写成`\.`以及`\`写成`\\`就当作普通字符来匹配 |
| `()` | 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符 | `([0-9]{1,3}\.){3}[0-9]{1,3}`匹配 IP 地址                                                     |
| `    | `                                                                    | 连接两个子表达式，表示或的关系                                                                | `n(o | either)`匹配`no`或`neither` |

以上介绍的是 `grep` 正则表达式的 Extended 规范，Basic 规范也有这些语法，只是字符 `?+{}|()` 应解释为普通字符，要表示上述特殊含义则需要加 `\` 转义。如果用 `grep` 而不是 `egrep`，并且不加 `-E` 参数，则应该遵照 Basic 规范来写正则表达式。

## 3. sed

`sed` 意为流编辑器（Stream Editor），在 Shell 脚本和 Makefile 中作为过滤器使用非常普遍，也就是把前一个程序的输出引入 sed 的输入，经过一系列编辑命令转换为另一种格式输出。`sed` 和 `vi` 都源于早期 UNIX 的 `ed` 工具，所以很多 `sed` 命令和 `vi` 的末行命令是相同的。

`sed` 命令行的基本格式为

```bash
sed option 'script' file1 file2 ...
sed option -f scriptfile file1 file2 ...
```

`sed` 处理的文件既可以由标准输入重定向得到，也可以当命令行参数传入，命令行参数可以一次传入多个文件，`sed` 会依次处理。`sed` 的编辑命令可以直接当命令行参数传入，也可以写成一个脚本文件然后用 `-f` 参数指定，编辑命令的格式为

```bash
/pattern/action
```

其中 `pattern` 是正则表达式，`action` 是编辑操作。`sed` 程序一行一行读出待处理文件，如果某一行与 `pattern` 匹配，则执行相应的 `action`，如果一条命令没有 `pattern` 而只有 `action` ，这个 `action` 将作用于待处理文件的每一行。

<p id="t32-5">表 32.5. 常用的 sed 命令</p>

| `/pattern/p`                     | 打印匹配 `pattern` 的行                                                       |
| -------------------------------- | ----------------------------------------------------------------------------- |
| `/pattern/d`                     | 删除匹配 `pattern` 的行                                                       |
| `/pattern/s/pattern1/pattern2/`  | 查找符合 `pattern` 的行，将该行第一个匹配`pattern1` 的字符串替换为 `pattern2` |
| `/pattern/s/pattern1/pattern2/g` | 查找符合 `pattern` 的行，将该行所有匹配`pattern1` 的字符串替换为 `pattern2`   |

使用 `p` 命令需要注意，`sed` 是把待处理文件的内容连同处理结果一起输出到标准输出的，因此 `p` 命令表示除了把文件内容打印出来之外还额外打印一遍匹配 `pattern` 的行。比如一个文件 `testfile` 的内容是

```text
123
abc
456
```

打印其中包含 `abc` 的行

```bash
$ sed '/abc/p' testfile
123
abc
abc
456
```

要想只输出处理结果，应加上 `-n` 选项，这种用法相当于 `grep` 命令

```bash
$ sed -n '/abc/p' testfile
abc
```

使用 `d` 命令就不需要 `-n` 参数了，比如删除含有 `abc` 的行

```bash
$ sed '/abc/d' testfile
123
456
```

注意，`sed` 命令不会修改原文件，删除命令只表示某些行不打印输出，而不是从原文件中删去。

使用查找替换命令时，可以把匹配 `pattern1` 的字符串复制到 `pattern2` 中，比如：

```bash
$ sed 's/bc/-&-/' testfile
123
a-bc-
456
```

`pattern2` 中的 `&` 表示原文件的当前行中与 `pattern1` 相匹配的字符串，再比如：

```bash
$ sed 's/\([0-9]\)\([0-9]\)/-\1-~\2~/' testfile
-1-~2~3
abc
-4-~5~6
```

`pattern2` 中的 `\1` 表示与 `pattern1` 的第一个 `()` 括号相匹配的内容，`\2` 表示与 `pattern1` 的第二个 `()` 括号相匹配的内容。`sed` 默认使用 Basic 正则表达式规范，如果指定了 `-r` 选项则使用 Extended 规范，那么 `()` 括号就不必转义了。

如果 `testfile` 的内容是

```html
<html><head><title>Hello World</title>
<body>Welcome to the world of regexp!</body></html>
```

现在要去掉所有的 HTML 标签，使输出结果为

```text
Hello World
Welcome to the world of regexp!
```

怎么做呢？如果用下面的命令

```bash
$ sed 's/<.*>//g' testfile
```

结果是两个空行，把所有字符都过滤掉了。这是因为，正则表达式中的数量限定符会匹配尽可能长的字符串，这称为贪心的（Greedy）<sup>[39]</sup>。比如 `sed` 在处理第一行时，`<.*>` 匹配的并不是 `<html>` 或 `<head>` 这样的标签，而是

```html
<html>
  <head>
    <title>Hello World</title>
  </head>
</html>
```

这样一整行，因为这一行开头是 `<`，中间是若干个任意字符，末尾是 `>`。那么这条命令怎么改才对呢？留给读者思考。

> <sup>[39]</sup> 有些正则表达式规范支持 Non-greedy 的数量限定符，匹配尽可能短的字符串，例如在 Python 中 `*?` 和 `*` 一样表示 0 个或任意多个，但前者是 Non-greedy 的。

## 4. awk

`sed` 以行为单位处理文件，`awk` 比 `sed` 强的地方在于不仅能以行为单位还能以列为单位处理文件。`awk` 缺省的行分隔符是换行，缺省的列分隔符是连续的空格和 Tab，但是行分隔符和列分隔符都可以自定义，比如 `/etc/passwd` 文件的每一行有若干个字段，字段之间以 `:` 分隔，就可以重新定义 `awk` 的列分隔符为 `:` 并以列为单位处理这个文件。`awk` 实际上是一门很复杂的脚本语言，还有像 C 语言一样的分支和循环结构，但是基本用法和 `sed` 类似，`awk` 命令行的基本形式为：

```bash
awk option 'script' file1 file2 ...
awk option -f scriptfile file1 file2 ...
```

和 `sed` 一样，`awk` 处理的文件既可以由标准输入重定向得到，也可以当命令行参数传入，编辑命令可以直接当命令行参数传入，也可以用 `-f` 参数指定一个脚本文件，编辑命令的格式为：

```bash
/pattern/{actions}
condition{actions}
```

和 `sed` 类似，`pattern` 是正则表达式，`actions` 是一系列操作。`awk` 程序一行一行读出待处理文件，如果某一行与 `pattern` 匹配，或者满足 `condition` 条件，则执行相应的 `actions`，如果一条 `awk` 命令只有 `actions` 部分，则 `actions` 作用于待处理文件的每一行。比如文件 `testfile` 的内容表示某商店的库存量：

```text
ProductA  30
ProductB  76
ProductC  55
```

打印每一行的第二列:

```bash
$ awk '{print $2;}' testfile
30
76
55
```

自动变量 `$1`、`$2` 分别表示第一列、第二列等，类似于 Shell 脚本的位置参数，而 `$0` 表示整个当前行。再比如，如果某种产品的库存量低于 75 则在行末标注需要订货：

```bash
$ awk '$2<75 {printf "%s\t%s\n", $0, "REORDER";} $2>=75 {print $0;}' testfile
ProductA  30    REORDER
ProductB  76
ProductC  55    REORDER
```

可见 `awk` 也有和 C 语言非常相似的 `printf` 函数。`awk` 命令的 `condition` 部分还可以是两个特殊的 `condition` —— `BEGIN` 和 `END`，对于每个待处理文件，`BEGIN` 后面的 `actions` 在处理整个文件之前执行一次，`END` 后面的 `actions` 在整个文件处理完之后执行一次。

`awk` 命令可以像 C 语言一样使用变量（但不需要定义变量），比如统计一个文件中的空行数

```bash
$ awk '/^ *$/ {x=x+1;} END {print x;}' testfile
```

就像 Shell 的环境变量一样，有些 `awk` 变量是预定义的有特殊含义的：

<p id="t32-6">表 32.6. awk 常用的内建变量</p>

| FILENAME | 当前输入文件的文件名，该变量是只读的               |
| -------- | -------------------------------------------------- |
| NR       | 当前行的行号，该变量是只读的，`R` 代表 record      |
| NF       | 当前行所拥有的列数，该变量是只读的，`F` 代表 field |
| OFS      | 输出格式的列分隔符，缺省是空格                     |
| FS       | 输入文件的列分融符，缺省是连续的空格和 Tab         |
| ORS      | 输出格式的行分隔符，缺省是换行符                   |
| RS       | 输入文件的行分隔符，缺省是换行符                   |

例如打印系统中的用户帐号列表

```bash
$ awk 'BEGIN {FS=":"} {print $1;}' /etc/passwd
```

`awk` 还可以像 C 语言一样使用 `if`/`else`、`while`、`for` 控制结构，此处从略。

## 5. 练习：在 C 语言中使用正则表达式

POSIX 规定了正则表达式的 C 语言库函数，详见 `regex(3)`。我们已经学习了很多 C 语言库函数的用法，读者应该具备自己看懂 man 手册的能力了。本章介绍了正则表达式在 `grep`、`sed`、`awk` 中的用法，学习要能够举一反三，请读者根据 `regex(3)` 自己总结正则表达式在 C 语言中的用法，写一些简单的程序，例如验证用户输入的 IP 地址或 email 地址格式是否正确。
